Tổng kết các bài đã làm, các lỗi sai, các phương pháp áp dụng thuật toán chi tiết hơn:

Các tool khác:
Đặt 1 biến kết quả riêng, update biến đó trong quá trình xây
Lưu dữ liệu ra 1 mảng riêng. Ta hay tách kiểu 1 dữ liệu ra lưu nhiều mảng, mỗi mảng đó có thể lưu, sắp xếp theo 1 trường gì đó hay làm gì đó khiến cho việc tính toán trên mảng gốc ban đầu dễ hơn. Như bài KQueue ta lưu sẵn ra 1 mảng sắp xếp tăng dần xong mỗi lần search dùng binary làm giảm độ phức tạp rất nhiều. Or bài LArray yêu cầu lọc 3 tập có tích >0,<0,=0 thì ta xây sẵn 3 mảng ngay từ lúc đọc là >0,<0,=0 r xử lý tiếp tích sẽ dễ hơn so với đọc thành 1 mảng dài khó nuốt => đơn giản hóa bài toán ngay từ lúc đọc đề
Khi giải các bài mà cần làm gì đó tạo 1 vòng for từ đâu đến đâu thì để dễ tính ta thg tính biến int start và biến int end rồi for từ start đến end. Vc tính start và end ta nên lấy ví dụ cụ thể để lấy cho chuẩn và tính nó thg là trực tiếp chứ k có loop gì cả
Kỹ thuật duyệt: Vd ta có 1 mảng số, ta cần tìm 2 số trong mảng a và b với điều kiện, a đứng trước b và (b-a) max => Thực tế bài toán con này được dùng rất nhiều trong các dạng bài khác mà ta còn lúng túng khi giải nó. Các giải rất đơn giản với O(n) => duyệt từ trái qua phải, để a lưu min = 999, res lưu max(b-a) = -999 => nếu nhỏ hơn a thì update a, nếu lớn hơn a và i-a > res thì update res và b=i, k thì thôi. Có thể mở rộng là b-a là max chẵn tương tự lưu aOdd và aEven xong làm như bth.
max_element(pointer first, pointer last);
viết 2^j bằng cách dùng 1<<j. VD for int i = 0 -> log(2n) thì ta for i = 0; (1<<i) <= n là được

Tool bài increasing subsequence: Để làm được với O(nlogn) thì việc rút gọn rất là khó nhìn ra. Ta phải nhìn vào bức tranh tổng quan bằng cách keep track vào thứ ta đang tìm. Ở đây tìm max length increasing subsequence: 7 1 3 8 1 2 4 9 => thì ta luôn lưu cả cái subsequence trong lúc duyệt luôn VD ta duyệt từ trái qua phải: 7->1->12->138->138->128->124->1249 -> thì 1249 là chuỗi dài nhất. Vì duyệt 7 rồi 1 thì nếu về sau gặp 1 số lớn hơn 1 thì số đó kết hợp với 1 sẽ tạo max inc sub. Nếu số đó lớn hơn 7 thì nó vẫn kết hợp với 1 tạo max inc sub-> như v 7 có thể bỏ đi luôn ở TH này. Tương tự 128 xong gặp 1 -> gặp 2 thì 2 nhỏ hơn 8 ta chèn vào 3 thành 128 rồi tiếp thế 4 vào 8 thành 124-> nếu về sau gặp số lớn hơn 4 thì lấy chuỗi này, gặp số lớn 8 vẫn lấy chuỗi này vì rõ ràng 4 nhỏ hơn 8 mà cùng độ dài thì nên lấy 4 hơn. Bước kết hợp này nhìn rất bá đạo nhưng thực tế kp ai cũng nhìn ra


*) Phân tích các dạng(viết sao cho nhìn tên là hiểu đề và biết cách giải luôn):
=> ADHOC:
 -Liệu tồn tại k số nguyên liên tiếp có tổng là x => khi đó: m + (m + 1) + ... + (m + k - 1) = x thì tồn tại m hay k thì: k*m + (k - 1)*k/2 = x thì (x - k*(k-1)/2)%k == 0 là thỏa mãn
 -Tính tổng 2 số có thể > 10^18: tính riêng tổng 18 số đầu và chữ số cuối %10 /10. In a + b = a/10+b/10 (a%10+b%10 > 10 ? + 1 : + 0) và in (a%10+b%10)%10
 -Bài rút gọn chữ dài(ez)
 -Bài gõ bàn phím cục gạch(ez)
 -Set contains bit mask kiểm tra mọi phần tử b có trong a ko(ez)
 -Check sự dịch chuyển trên map 2 chiều: không lưu mảng 2 chiều vì k đủ bộ nhớ vì ta chỉ cần lưu các giá trị 1 ở vị trí nào nên dùng vector pair. Chạy 2 vòng for các vị trí của 1 trước và sau và lưu 1 mảng 2 chiều sự dịch chuyển theo 2 trục, cái nào nhiều nhất thì lấy. Nó như 1 kiểu duyệt trâu mọi sự thay đổi. Phải dùng mảng +1000 phần tử để lưu 2 nửa âm dương
 -REROAD tính độ gập gềnh của đường mỗi khi phủ lên 1 loại nhựa đường ở 1 vị trí: xử lý tốc độ O(1). Xét 2 ô ở 2 bên so với ô hiện tại và khi thay vào thì số nhựa đường liên tiếp tăng hay giảm. Chú ý ở 2 đầu mút thì xét 1 bên.
 -Tìm trong chuỗi theo thứ tự 3 giá trị b, a, c sao cho b-a và c-a có tổng lớn nhất và cả 2 lớn hơn 1 giá trị xác định k: ta duyệt tuyến tính và luôn lưu max cho đến giá trị hiện tại. Nếu max - gt tiếp theo lớn hơn k thì for tìm max giá trị bên phải là xong. Để giảm độ phức tạp mỗi khi tìm ra b, a thỏa mãn ta k thể for tiếp được mà sẽ lưu lại giá trị a min hiện tại và các giá trị a về sau duyệt phải nhỏ hơn a min này mới lấy. Vì nếu lớn hơn a min này thì b+c-2a chắc chắn sẽ lớn hơn gt tính trc đó. Khi đi qua max phải, thì khi thì khi cần mới phải tìm lại max phải, còn không lấy luôn max phải có sẵn
 -CMD(ez)
 -Bracket sequence tìm lượng ngoặc đúng dài nhất trong hàng đống ngoặc: dùng stack check ngoặc đúng sai-> nếu sai ta lấy tất cả các ngoặc đúng trước đó để xử lý, nhưng đã duyệt qua rồi k lấy được nên phải dùng thêm 1 stack nữa lưu mọi ngoặc trong lúc duyệt và k pop ra như stack check-> gặp đúng thì lấy-> gặp sai thì lây ra cụm ngoặc đúng là kết quả bằng cách duyệt và check ngược lại-> clear toàn bộ và duyệt tiếp (Dùng duplicate stack)
 -Xây 3 tập có tích ><= 0 từ 1 mảng số(ez)
 -Alternating current(ez)
 -Union doubly linked list: lúc đọc thì xây luôn các node start của các linked list-> dựa vào từng node start nối lại xây lên các linked list while right khác null thì nối cái right đó-> nối từng cục linked list đầu cái này với cuối cái trước. Trong lúc nối ta xây *final để lấy được điểm cuối từ điểm đầu 1 phát luôn để nối cho nhanh. 
 -Combination gen sinh combination tiếp theo của combination hiện tại n phần tử từ tập m phần tử: éo backtrack gì hết=> duyệt ngược về, nếu gặp phần tử chưa được max ở vị trí đó thì ++ lên là xong(mẹo)

=> Backtracking: 
 -In mọi xâu binary n phần tử: candidate {0, 1} xếp đủ n là in
 -Xếp n queen vào nxn ô có hole: đi được 1 ô thì check cột, 2 đường chéo có row-col và row+col = hso xây mảng check nếu thỏa mãn thì lấy. Nhớ TH trừ có âm phải + n/2
 -Knapsac: Ta thêm các đồ vật vào túi nếu đồ vật chưa được thêm và đồ vật đó nếu thêm vào không bị quá khối lượng thì ok, naive làm đk dừng kiểu lấy min các đồ vật còn lại mà lớn hơn remain quantity thì dừng lại nhưng việc lấy min là thêm 1 vòng for là toang=> khắc phục bằng cách khiến cho cái min đó ta k cần tìm nx mà luôn có => sắp xếp cái mảng theo chiều giảm dần mass thì min mass của toàn bộ data ta có thể lấy làm minMass của phần data còn lại, ta đặt thêm biến start truyền vào sau mỗi vòng để các đồ vật phía sau không bị lặp lại cái permutation đã xét. Nên nhớ ta duyệt k lặp như v từ 0 đến n thì phần tử thứ n luôn là phần tử cuối cùng duyệt trong số các phần tử nên ta đảm bảo nó là min đống còn lại => occho
=> Trap: Khi có start thì k cần isVisited nx; truyền vào start cho vòng sau chính là i+1 hiện tại chứ kp start+1 của vòng hiện tại.
 -Tìm thứ tự thứ k permutation của n (n < 10^4) và k cực lớn: Dù k lớn thế nào thì cx chỉ dùng đến tầm 13 chữ số cuối của n(khi k = 13! ~ 6*10^9) nên ta có thể check nếu n >= 13 thì ta in ra vẫn y nguyên n - 13 chữ số đầu và nhét các chữ số còn lại vào mảng và thực hiện backtrack permutation trên mảng đó. Tuy nhiên do permutation list duyệt có lặp nên n = 13 thì kết quả có thể time limit, thậm chí 12 cx k đc. Thứ tự từ điển thứ 13! sẽ chỉ đổi 13 số cuối, thứ 12! sẽ chỉ đổi 12 số cuối. Chẳng hạn k / 12! = 3 tức là hoán vị đụng đến 13 số cuối và vị trí đầu bị hoán vị tăng lên 3 số tức là từ 1 đến 20 thì sẽ là 1 2 3 4 5 6 7 và 13 số sau bị hoán vị lên 3 lần 12! nên sau số 7 sẽ là số 11 -> ta in ra 11 và bỏ khỏi mảng cần permutation. Sau đó ta có thể permutate mảng đó với k%12! => lấy code có sẵn
 -In binary list thứ n không chứa k số 0 liên tiếp: backtrack bth dùng thêm 1 biến lưu số các số 0 liên tiếp ở hiện tại, nếu lớn hơn k thì ko lấy. Nhưng nếu gặp 1 thì reset về 0 r backtrack lại thì mất-> dùng mảng để lưu số lượng số 0 liên tiếp gắn với phần tử thứ i là ok ngay, backtrack k sợ mất=> truyền vào hàm k cần mảng
=> Việc truyền vào hàm mỗi lần cũng như việc mỗi vòng lưu 1 thứ gì đó. Nếu ta định dùng mảng để lưu lại thứ đặc trưng riêng của mỗi vòng recursion thì hãy nghĩ đến cách này trước
 -Bracket tìm số cách điền ngoặc vào ? của string tạo string ngoặc đúng có nesting depth < k: tính chất của depth = 0, gặp ( thì ++, gặp ) thì -- => nếu về cuối bằng 0 thì thỏa mãn. Điều kiện branch and bound là cái depth thỏa mãn <k và depth > 0 để k bị sai. Việc check depth == 0 cx là 1 cách nhanh check tính đúng sai của ngoặc khi chỉ có 1 loại ngoặc. Thay vì tạo tập các vị trí có thể xếp ta xếp mọi TH và if else để xử lý từng cái như nào=> dạng viết khác của backtracking. Tương tự có thể dùng nhiều biến depth để chỉ độ depth của nhiều loại ngoặc khác nhau.
=> Vc chọn ô nào thì mới for để chia if else ra khá hay chứ kp như mấy bài bình thường, ô nào ta cùng for, có những ô ta k for được mà bỏ qua chứ thì if else ngay trong Try sẽ hay hơn

=> Divide and conquer:
 -Maxsub array: 0 -> n-1 thì maxsub rơi vào bên trái, phải, 1 phần trái 1 phần phải
 -Max area of hist: max area sẽ nằm bên trái min height, bên phải min height or chứa min height. TH chứa min height tính dễ vl vì lấy toàn bộ các ô rồi. Lấy min height từng phân đoạn dùng segment tree trả ra index của ô min height
 -Tính a^b mod c cực lớn: a^b = a^(b/2)*a^(b/2) nếu b chẵn và = a^(b/2)*a^(b/2)*a nếu b lẻ. Gom a^(b/2) vào 1 biến gọi 1 lần để tiết kiệm, nhớ chia mod liên tục nx
 -Mod of sum of sum of very big number: Với các bài tính dãy dài như này k ai dùng for cả mà sẽ rút gọn công thức. Sum of sum như này rút gọn là: n(n+1)(n+2)/6 và n cực lớn, ta tính với mod m và m cũng cực lớn tầm 10^18 => ta k thể nhân nó vào rồi chia 6 được kể cả có nhân vào rồi mod vì chính m cũng lớn=> buộc dùng divide and conquer giải quyết phép nhân với mod này. Ta nhân n với n+1 mod m rồi lại nhân với n+2 mod m. Để nhân ta phải chia phép nhân đó ra: a*b = a*b/2 + a*b/2 nếu b chẵn còn b lẻ thì a*b = a + a*b/2 + a*b/2 => / là chia lấy nguyên => cứ mỗi lần chia đôi ra là lấy mod luôn. Base case là chia đến khi b=1 thì trả ra a. mod k có tính chất với phép chia nên cần check số nào trong 3 số chia hết cho 2 và 3 thì chia trước. Ở đây cx chỉ là thực hiện phép nhân bình thường. Lưu ý là DaQ cho phép ta nhân bất cứ 2 số nào kể cả >10^18 từ từ tối ưu nhất k bị overflow.
 -Tìm hiệu lớn nhất số sau trừ số trước với O(nlogn): chia đôi ra. Tìm min nửa trái, max nửa phải và trừ đi, đồng thời gọi đệ quy tương tự với trái và phải. DaQ hay kiểu return lại vc gọi hàm. Nếu cần tìm max 2 biến trái phải và xen giữa thì có thể gọi max lồng max ez, k cần tạo hàm mới.
 -Tìm 2 điểm có khoảng cách min trên mặt phẳng: sắp xếp chúng theo chiều tăng dần trục Ox và Oy-> divide and conquer kiểu bth chia đôi dần số điểm ra. Dùng 1 biến lưu kc minVal và update liên tục. Xử lý TH 1 điểm nửa trái, 1 điểm nửa phải: Nếu brute force hiển nhiên là 2 vòng for chạy O(n^2) rồi nhưng bh giải đã đơn giản và nhanh hơn=> ta lấy nửa trái và phải cặp điểm cách mid theo trục Ox 1 đoạn bằng minVal, 2 điểm đó sẽ là đầu mút 2 bên ta duyệt for lồng 2 vòng. Nó đã đơn giản hơn rất nhiều vì for rất ít phần tử, càng tính minVal càng nhỏ thì for càng ít phần tử hơn về sau. Lần lấy nhiều nhất thì ít phần tử nhất chỉ có 2 cái 2 bên. Để tìm 1 node cách mid 1 khoảng là minVal ta dùng upper/lower bound binary search vì mảng ta đã sắp xếp sẵn r. Duyệt trái và phải thì vẫn lâu vì nếu trục y nó sắp xếp quá nhiều cùng 1 giá trị x. Ta dùng tính chất do ta đang tìm minVal mà ở cả trái và phải k có 2 điểm nào thuộc cùng 1 bên mà có khoảng cách nhỏ hơn minVal. Lúc này ta lại gom các điểm lại và sắp xếp theo chiều tăng y. Xong for từ cái y thấp nhất->cao nhất chỉ cần tìm tầm 10 y thấp hơn nó là đc.
 -Tìm số lần xh của pattern p trong fibonacii word: quá gắt DaQ lồng DaQ. Check p trong f[n] = f[n-1] + f[n-2] thì p nằm bên f[n-1], p nằm bên f[n-2], p nằm xen giữa 2 f đó. Xử lý p nằm giữa 2 f: ta tìm điểm start và end của nửa p nằm bên f[n-1] và for nó check ở 2 bên, nếu bên n-1 có thì check xem bên n-2 có phần còn lại k. Để check phần p chia ra có nằm trong f[n-1] k thì lại divide and conquer tiếp. Check length p < length n - 2 thì p nằm gọn trong phần bên n - 2 của f[n-1] thì lại gọi DaQ tiếp tương tự còn length p > length n - 2 thì tách string đó ra gọi lại với phần n - 2 và phần còn lại thuộc n-1 lại gọi đệ quy. Cái lần DaQ thứ 2 nó như 1 bài toán riêng luôn nhưng bài toán này dễ hơn vì kp chia r gộp combine lại nửa này nửa kia mà ta chỉ chia theo n về n-2 và n-1 rất ez. Base case của nó tương tự như base case bài lớn thôi. Check đk các thứ đầy đủ là đc. Dùng cả mảng memorization để kp tính lại khi trùng. Tính chất: chiều dài của fiboword chính là dãy fibonacii và số fibo tầm 100 đã lên tới 10^19 rồi nên các bài fibo thg k quá 100 số, bài này ta cứ tạo ra chuỗi số fibonacii để có thể lấy length bất cứ lúc nào. VD để in ký tự thứ i trong fiboword f[n] thì ta check xem ith thuộc n-1 hay n-2 rồi gọi lại đệ quy với n-1 or n-2 và cứ thế cho đến khi n giảm về 1.

=> Dynamic Programming 1 chiều:
 -Maxsub array: tuyến tính, xây mảng lưu dãy con lớn nhất kết thúc bằng phần tử thứ ith
 -Max area of hist: stack lưu height tăng dần, gặp nhỏ hơn thì tính và pop các height lớn hơn r push vào chỉ có height tăng dần. Vì duyệt gặp thanh lớn hơn, đó sẽ là nơi bắt đầu của S chứa thanh đó còn gặp thanh nhỏ hơn sẽ là nơi kết thúc của thanh đó. Dựa vào index để tính width dễ dàng.
 -Gold mining chọn rương cách nhau từ L1 đến L2 để có max gold, n tầm 10^5: [i] là số lượng gold max được chọn chứa rương thứ i và kết thúc tại rương thứ i thì [i] = max(từ i-L2 đến i-L1) + amount[i]
 -Gold mining với n lớn hơn: Vòng for thứ 2 là để ta tìm max từ i-L2 đến i-L1, ta có thể giảm đi bằng cách dùng priority_queue thêm và bớt vào queue sau mỗi vòng duyệt và lấy ra max với O(1). push vào queue sau mỗi vòng, pop khỏi queue trước mỗi vòng nếu giá trị đó không thuộc từ i-L1 đến i-L2
 -Tìm max even subarray: tạo ra mảng arr[i] chứa tổng cho đến vị trí ith. Duyệt O(n) và update maxVal với arr[i] và max của arr[i] - arr[i trước đó] là số chẵn. Cái max đó update dựa vào phần tool bên trên. Điều đặc biệt là check số lẻ thì ta phải if(a%2=1||a%2=-1) nhé
 -Tìm 2 khoảng thời gian hoạt động k overlap cho nhiều sp nhất của machine: chỉ cần tìm 2 khoảng thời gian tức là end của cái này < start của cái sau sao cho max tổng 2 period=> ta xây 1 mảng lưu period dài nhất nếu chọn end vào lúc nào. Sau đó chỉ cần for từng period và lấy nó cộng với arr[start] là đc
 -Longest increasing subsequence n=10^4: 10^4 ta có thể làm với O(n^2). arr[i] lưu length of longest increasing subsequence kết thúc tại phần tử thứ ith. Duyệt 1 vòng for, bên trong lại có vòng for nx update arr[i] với arr[j]+1 nếu j < i => xong tìm max trong arr[i] là có kết quả. 
 -Longest increasing subsequence n=10^6: 10^6 ta buộc làm với O(nlogn). Buộc phải giảm vòng for thứ 2. Tương tự như bài trước, ở đây nó tìm max length của các element có val nhỏ hơn val hiện tại. Nhưng không có kiểu dữ liệu nào sắp xếp theo val rồi xong lại tìm max được như v cả, nên cách này éo ổn=> Thực tế để rút gọn được ở TH này rất phức tạp. Dùng tool chứ khó vl.
 -Tính RMQ of nhiều min từ các khoảng khác nhau: dùng segment tree;
 -Số lượng xu min tạo ra giá trị: arr[i] là số lượng xu min tạo ra giá trị i. Base case là khi các đồng xu vào nhỏ hơn giá trị xu min thì arr[]=0. Nếu giá trị bằng 1 trong giá trị các đồng xu thì là 1. Nếu i > coin[k] và arr[i - coin[k]] != 0 thì arr[i] = max(arr[i - coin[k]]) + 1 vì nếu arr[i-coin[k]]=0 tức là k có cách nào xây nên giá trị đó cả thì các giá trị sau tạo từ nó cũng phải bằng 0

=> Dynamic Programming mảng 2 chiều:
 -Nurse có bao nhiêu cách xếp lịch làm và nghỉ so le với số ngày làm từ K1 đến K2: arr[i][j] lưu số cách xếp lịch cho đến ngày thứ ith với j = 0 là kết thúc bằng 1 ngày nghỉ; j = 1 là kết thúc bằng 1 ngày làm việc; arr[i][0] = arr[i - 1][1]; arr[i][1] = arr[i - k][0] với k lấy từ for số ngày làm việc. Nếu k có ngày nghỉ thì ta chỉ cần dùng mảng 1 chiều nhưng có ngày nghỉ nên tính toán bị khác phải dùng chiều thứ 2. Ta cứ xây bằng PP đơn giản hóa 1 chiều là sẽ nhận ra ngay để tính cha từ con rất khó vì kb nghỉ hay làm từ đó ta suy ra rằng cần có 1 mảng 2 chiều lưu thêm.
 -Longest common subsequence: arr[i][j] lưu length of longest common subsequence cho đến vị trí i của chuỗi 1, j của chuỗi 2. Nếu vị trí i mà trùng với j thì arr[i][j] = arr[i-1][j-1] + 1, còn nếu khác thì arr[i][j] = max(arr[i-1][j],arr[i][j-1]). Khi xây vị trí a[i][j] ta phải nghĩ là mọi vị trí trước đó đều đã có hết r. Thì khi thêm vào 1 vị trí i, j mới thì i==j thì phải cộng từ cái [i-1][j-1] vì dynamic nên nó lưu max cho đến vị trí đó rồi, thêm 1 cái nx thì +1 lên thôi. Còn i!=j thì i có thể trùng với 1 cái gì đó trước đó trong chuỗi j và j cũng v thì a[i][j-1] và a[i-1][j] đã lưu sẵn max length khi chỉ thêm i or chỉ thêm mỗi j từ [i-1][j-1] rồi nên nó là max 2 cái đó quá chuẩn
 -warehouse pick hàng ở các station biết khoảng cách 2 station liên tiếp để pick và thời gian pick bị giới hạn: a[i][j] là cách pick có số hàng hóa nhiều nhất dùng đến station thứ i và dùng đến j thời gian. Để update [i][j], for các station trong phạm vi max distance 2 station liên tiếp và lấy max hàng hóa vị trí đó dùng đến j-t[i] thời gian và cộng với số hàng tại [i].
 -Chia cửa hàng cho chi nhánh, mỗi chi nhánh có 1 lượng người, số lượng cửa hàng chia cho chi nhánh phải chia hết cho số người trong chi nhánh, tìm số cách chia: [m][n] chia m cửa hàng cho n chi nhánh sao cho chi nhánh n chắc chắn có cửa hàng; [m][n] = [m-f[n]][n] + [m-f[n]][n-1].
 -Cắt phiến đá W,H thành các phiến đá nguyên sao cho phải mọi nhát đều là cắt đôi và S thừa ít nhất: [m][n] lưu diện tích thừa của mảnh rộng m, dài n. Ta for mỗi viên gạch con và trừ đi nó ở góc lấy các cái đã tính. Do chỉ cắt đôi nên mỗi viên gạch mới ta phải xét 2 cái res[i][j] = res[i][j - h[t]] + res[i - w[t]][h[t]]; res[i][j] = res[i - w[t]][j] + res[w[t]][j - h[t]];
 -Số cách khác nhau chọn ra các đồng xu tạo giá trị S: arr[m][n] dùng đến m đồng xu tạo ra giá trị n. Thì arr[m][n] = [m-1][n] + [m][n-coin[m]] tức k có đồng m or ít nhất 1 đồng m
 -Ăn táo trên table từ 00 đến nn sao cho đc nhiều táo nhất: res[m][n]=max(res[m][n-1], res[m-1][n])+a[m][n]
 -Drone pickup, drone đi đến 1 nơi là nạp nhiên liệu và chất hàng và trở đi, tìm đường có nhiều hàng nhất biết buộc phải đi từ node đầu và kết thúc tại node cuối: Nhiều bài dynamic làm bottom to top bth thì ok nhưng dùng recursive thì bị timelimit kể cả ta đã dùng memorization(recursive như kiểu cách viết khác của backtracking v). Do đó ưu tiên làm bottom to top vòng for bth hơn là recursive, recursive với dynamic thì thg có bitmask hơn. [m][n] là drone đi đến vị trí thứ m và đã đi qua n vị trí => cứ for lồng for xây như 1 bài dynamic bth thôi. Ta tưởng tượng rất chặt rằng muốn tìm thì buộc phải tìm mọi TH là đi từ node đầu tới mọi node khác và cuối cùng dừng lại ở node cuối. Ta k thể bỏ 1 node nào được vì rất có thể nó là đoạn đường dị dẫn tới node cuối với con đường ngắn nhất. Dynamic nó như 1 cách gộp chung duyệt trâu nhưng mà nhanh hơn v. Ở đây ta dùng đúng PP cũ là nếu brute force ta duyệt 2 vòng for thì rất có thể nó là mảng 2 chiều trong dynamic đó => [m][n] = [k][n-1] + load hiện tại với k là mọi node trước đó(lấy max của nhiên liệu và lùi 1 lượng thôi chứ kp lúc nào cx for từ 0). Phải check k vượt quá lượng vị trí max và k quá tổng số vị trí thì mới tính
=> Chú ý lỗi sai: ở đây ta duyệt 2 vòng for xong lồng thêm 1 vòng for thứ 3 vào trong để tìm với mọi node trước đó=> nhưng nên nhớ đó là hoàn toàn bth vì đề bài có cho chỉ tầm 3000 nên 10^3 thừa sức chơi. Ta lại cứ tưởng là vòng for lồng tiếp nó quá lớn nên nghĩ cách khác luôn nhưng thực chất cách trực tiếp này lại là tốt nhất. Vòng for trong là max lượng vị trí có thể visit thì chỉ còn 100 thôi nên có thể coi là hằng số thoải mái ở TH này. Chính vì v nên bài này chỉ coi dễ như 1 bài bth
 -Maximum Partition chia arr thành k sub nhỏ có tổng các min mỗi sub là lớn nhất: [m][n] là dùng đến n phần tử chia thành m subarray

=> Dynamic bitmask:
 -TSP: iMem[i][S] lưu đã visit các thành phố xác định trong S và bắt đầu visit tiếp từ thành phố i. Để tính iMem[i][S] = max của TSP(visit tiếp từ i, các thành phố chưa visit mà visit được từ i) + fee[i][thành phố visit tiếp đó] => để lấy max phải dùng vòng for. Nếu visit đến 1 vị trí bị tắc thì iMem để mặc định và check ở thành phố 1 nếu mặc định thì bỏ qua là đc.
 -CBUS: tương tự chỉ là trước khi gọi đệ quy ta check và update biến check, và sau khi gọi đệ quy ta backtrack như chưa từng visit node này là đc.
 -TAXI: tương tự nhưng ta gom nhanh hơn. Thay vì đi phải check nhiều điều kiện ta coi chỉ có n vị trí và khi đón 1 hành khách ta tự tính luôn phí đón khách đó + phí trở họ đến đích + xuất phát từ đích đi tới mọi nơi khác.

=> PP chặn 2 đầu tính gần đúng giá trị: 
 -PIE có nhiều bánh bán kính khác nhau, chia phần bánh cho mỗi người 1 lượng như nhau lớn nhất mà phần bánh của mỗi người lấy chỉ từ 1 cái bánh: biến là phần bánh cho 1 người, cận trên là bán kính cái bánh lớn nhất, cận dưới là 0. So sánh với số lượng người hiện tại. Sau khi có bán kính, tính số người bằng tổng volumne từng bánh chia cho volumne đó
 -EKO cưa cây lấy gỗ 1 lượng nguyên từ 1 list cây chiều dài nguyên: biến là mức cưa, right là chiều cao cây cao nhất, left là 0, so sánh với lượng gỗ cần dùng. Do ta cần cưa lượng nguyên ít nhất phải đủ lượng required nên while left <= right thì ta sẽ lấy right sau cùng.
 *-Chia 1 dãy sách liên tiếp cho mỗi scriber sao cho người có nhiều page nhiều nhất là nhỏ nhất: 1 nhóm sách liên tiếp sẽ được assign cho 1 người. Nhưng rõ ràng k thể mỗi người đều có 1 lượng trang như nhau được nên biến phải là số trang max được assign cho 1 người. left là sách có nh trang nhất, right là tổng số trang của mọi cuốn sách. So sánh với số lượng scriber. Khó khăn: xử lý TH trùng nhau. Vd: 1 1 1 1 1 chia cho 4 người thì 1/1/1/11 tức max tìm được là 2. Ta xử lý left=1, right=5 thì nếu max là 2 thì là 3 người còn max là 1 thì là 5 người nên hiển nhiên lấy 2 rồi. Xong lúc in phải cẩn thận do scriber thứ nhất assign ít việc nhất nên duyệt từ phải qua in 1 1 và check nếu số scriber bằng số lượng sách còn lại thì in tất cả với / luôn vì mỗi scriber ít nhất 1 cuốn mà
 -AGGRCOW khoảng cách nguyên ngắn nhất giữa 2 con bò liên tiếp là lớn nhất: biến là khoảng các min giữa 2 con bò(kc 2 con bò phải lớn hơn cục min này), min là khoảng cách gần nhất giữa 2 trại, max là khoảng cách 2 trại ở 2 đầu mút, so sánh với số lượng bò. Lưu ý là vì khoảng cách 2 con bò k như nhau nên k thể đặt biến là kc 2 con bò được mà là kc min giữa 2 con bò. Có thể sắp xếp số liệu để làm gì đó => điều đb là kết quả tính ra kp kq ta lấy. Sau đó ta vẫn phải duyệt 1 lần nữa để tìm kc min thật sự. VD 3 con bò với 3 trại: 1 10 100 thì thứ ta tính ra là 50->25->12->6 nhưng 6 kp kết quả mà phải chạy 1 vòng for nx để lấy 9 mới là kq

=> Graph:
Basic:
 -Đếm connected components: số lần duyệt BFS, DFS là số connected components;
Union_Find:
 -Tìm MST weight graph: dùng Kruskal với Union_Find. 
Ứng dụng DFS:
 -Check bipartile graph: cứ duyệt và gán so le 01, nếu gặp cái đã duyệt mà cùng sides 0 or 1 thì k là birpatile graph tức cycle dài lẻ đó. Có thể truyền thêm node parent là parent của node hiện tại để check so parent với node hiện tại or check mẹ trong vòng for.
 -Tìm cặp edge nếu nối sẽ tạo duy nhất 1 cycle: Thuật toán tarzan check bridge, nếu là bridge thì thêm vào 1 adjacency list mới và tính số node của mỗi connected components trong graph mới và tính ra số cặp node theo công thức mò ra ez. 
 -Tìm bridges và articulation points: dùng DFS xây low và num xđ bridges; articulation points nếu làm kiểu 2 đầu bridge là sai vì có 2 TH cycle thì có 1 TH 2 cycle nối cùng 1 điểm vẫn tạo articulation points và nếu dùng như v rất phức tạp. Ta giải quyết TH tổng quát, xét edge từ u đến v thì nếu low[v] > num[u] thì đó là articulation point như trong graph mẫu. Xử lý các TH ngoại lệ: nếu là node lá thì k lấy thì k cần lo vì ta xét mọi edge u->v để lấy u, nếu k có edge thì k lấy nên tự loại bỏ; nếu là node bắt đầu thì k lấy nhưng nếu TH cycle loại 1 mà bắt đầu duyệt từ node giao thì nếu có 1 cycle thì k lấy, 2 thì lấy=> tức là nếu bắt đầu từ 1 node mà node đó có 2 con k cùng trong 1 cycle thì mới lấy cái node đầu ta xét riêng ra là xong. Do có nhiều connected components nên mỗi lần duyệt cần refresh lại cái số lượng child duyệt tới mà chưa từng duyệt tới lần nào là 0 => cái hay là ta có thể check node root TH giao mấy cycle như này
 -Tìm elementary path in tree có length lớn nhất trong 1 tree(nếu k trong 1 tree thì check có cycle sẽ phải cộng với những 2 nhánh nx cơ sẽ rất phức tạp): duyệt DFS sẽ cho ta duyệt từng nhánh và sau khi kết thúc mỗi nhánh và backtrack về node hiện tại. Khi backtrack về ta + length nhánh đó với length longest cho đến h của node hiện tại(mặc định là 0) và so sánh update với res. Cx update length longest của node hiện tại sau mỗi vòng for.
 -Check directed graph có strongly connected hay k: duyệt từ 1 đỉnh tới mọi node, đảo ngược mọi chiều, lại duyệt từ đỉnh đó tới mọi node. Vì 1 graph là strongly connected nếu từ 1 node bất kỳ duyệt tới mọi node khác được và từ mọi node đều đi tới node đó đc.
 -Tìm strongly connected components của 1 graph: tức tìm các subgraph của 1 graph có tính chất strongly connected, các subgraph lớn nhất và k đề nhau. Strongly connected components thỏa mãn là các cục cycle và từng node rời nhau nếu k ở trong cycle bởi vì là directed(k chơi multigraph) nên phải có cycle mới đi được từ mọi node tới mọi node chứ. Ta k thể check nếu backtrack về mà k ở trong cycle thì đó là 1 strongly connected components riêng được vì 1 node có nhiều nhánh, nhánh này k trong cycle nhưng nhánh khác trong cycle thì sao=> Ta xây low, num, mỗi khi duyệt 1 node sẽ add vào stack-> kết thúc vòng for ta check nếu node hiện tại có low=num thì node đó là điểm node của 1 strongly connected components và ta pop từ stack ra cho đến khi gặp node đó. Ta phải xử lý nếu duyệt 1 node đã duyệt thì phải check nếu nó chưa thuộc connected components nào thì mới update low num để cho nó là điểm node của strongly connected components chứa node hiện tại. Còn nếu nó đã thuộc 1 connected components khác r thì ta k lấy mà connected components chứa node hiện tại sẽ ngắt tại đó. Khi đó ta phải dùng 1 biến boolean, khi pop nó ra thì gán cho nó bằng false và nếu duyệt 1 node nối với node hiện tại mà false thì coi nó chưa từng tồn tại bỏ qua luôn mà k gán low num cho nó nx. Pop nó ra đến khi pop xong phần tử stack mà bằng với phần tử có low=num hiện tại=> tốc độ vẫn chậm vì bên trong DFS mà thực hiện thêm vòng while thì tốc độ bị nhân lên. Ta dùng 2 lần DFS rời còn nhanh hơn.
    => Tìm strongly connected tốc độ cao hơn k dùng low, num: cho 1 graph bất kỳ, 1 cục là strongly connected components trong graph thì duyệt từ nó tới mọi node trong cục và đảo chiều vẫn duyệt được như v. Duyệt DFS 1 lần và push vào stack sau mỗi vòng for, khi kết thúc stack sẽ lưu tất cả theo thứ tự duyệt DFS. Trong stack sẽ lưu liên tục nhau các components và các components đó có thể duyệt được theo 1 chiều xuôi r. Lấy 1 graph khác mà có chiều đảo lại(xây từ lúc lấy input), dùng DFS để duyệt từ node đó trở đi(tức duyệt ngược lại với chiều ban đầu) vì chiều xuôi ta đã xác nhận là đi được tới node này nên nếu chiều nghịch node này đi được tới những node nào, thì những node đó với node này sẽ cùng chung 1 strongly connected components, ta cộng counter lên. Ta dùng stack là để có thể lấy các node ra theo thứ tự duyệt DFS ngược lại. Mỗi lần lấy ra phải check chưa được duyệt tới theo chiều ngược lại thì mới cộng counter=> 2 lần dfs rời nhau nhanh hơn là thao tác bên trong
 -Cho 1 list công việc, việc i phải thực hiện trước việc j, in ra thứ tự thực hiện các công việc sao cho thỏa mãn: đọc dữ liệu thì xây graph j->i. Xong duyệt DFS và push vào stack node hiện tại sau khi vòng for hiện tại kết thúc. Nếu thêm vào stack trước khi chạy vòng for thì ta sẽ có thứ tự xuôi của DFS. 
 -Check quan hệ cha con nhiều node trong tree DFS theo thứ tự duyệt: duyệt DFS, mảng d tại mọi node lưu thứ tự được duyệt tới của node đó-> đặt curNum=0 và d[u]=++curNum trước vòng for node u. Mảng f tại mọi node lưu thứ kết kết thúc node đó-> sau vòng for gán f[u]=++curNum. Tức 1 node mà k có con nào chưa duyệt thì sẽ có f[u]-d[u]=1, các node nào là lá or là khởi đầu của 1 backedge thì f-d=1 vì ta không duyệt được 1 con nào chưa từng duyệt của nó cả. a là con của b nếu d[a]>d[b] và f[a]<f[b]. Tận dụng gán d mọi u là -1 và có thể check d != -1 là đã duyệt node này thay vì dùng isVisited
Ứng dụng BFS:
 -Tìm shortest path trong directed unweight graph: dùng BFS duyệt từ 1 node là đầu đi của path cần tìm. BFS bình thường vd duyệt từ u có thêm 2 con a và b chưa duyệt thì pop u và add a và b vào queue nhưng làm thêm 1 bước là update dis[a] = 1 + dis[u] và pred[a] = u. Sau cùng dis[x] là khoảng cách min từ x tới node cần tìm(là node duyệt đầu tiên) còn path đến x thì ta lấy từ từ: m = pred[x] xong lại lấy pred[m] cho đến khi pred[m] == node gốc là các node trên shortest path. Ở đây pred[x] lưu 1 giá trị là node trước x trên shortest path. Duyệt BFS không thôi đã cho ta tính chất là shortest path rồi. Ta có thể duyệt BFS cho đến khi gặp node cần tim còn bên trên là làm tổng quát tính kc từ nhiều node tới node cần tìm chứ k chỉ 1.
 -Thang máy bấm lên or xuống sẽ đi 1 lượng floor cố định, tìm số cách bấm min để lên được 1 tầng chỉ định nếu được: tree BFS gán level, nếu level chưa được gán tức chưa duyệt thì push vào queue. Nếu tầng hiện tại bằng với tầng đang tìm thì chả ra level tầng đó.
 -Buglife xem 2 con bug tương tác nhau có giới tính giống nhau k: cũng như tìm cycle có số node chẵn, ta dùng BFS để xem nếu gặp 1 node đã visit mà level cùng odd or even thì là cùng giới tính
 -Check birpartile graph: cứ đã visit mà level cùng chẵn lẻ là sai thôi
Ứng dụng PRIM:
 -Tìm MST weight graph: dùng PRIM tìm, 2 mảng là 1 cái lưu khoảng cách min từ mọi node tới cục tách riêng, 2 là lưu node nào cần lấy-> cần tạo biến lưu đủ thông tin cần thiết để khi duyệt 1 edge từ 1 node trong cục tách riêng, ta có thể lưu đủ thông tin của edge đó để dùng về sau như weight, bắt đầu từ điểm nào bên ngoài, có tính chất nối với điểm nào bên trong. Dùng priority_queue để lấy kc min với tốc độ nhanh nhất. Chọn cấu trúc để lưu k hề đơn giản, ta muốn lưu khoảng cách tới cục tách riêng min thì dùng priority_queue nhưng nếu lấy ra kc min rồi thì ta cần phải biết kc min đó là cạnh nối 2 node nào chứ để mà lấy nó add vào res chứ. Do đó priority_queue mới lưu 1 cặp pair là kc và node và nó sx theo kc. Mỗi khi lấy ra kc min thì ta lấy ra được node bên ngoài nào nối với cục tách riêng. Xong ta phải lấy cả node trong cục tách riêng nối với node bên ngoài đó với tốc độ O(1) chứ k đc dùng vòng for. Do đó trong bài ta dùng thêm 1 mảng iBest[i]=a lưu node i bên ngoài nối với node a trong cục tách riêng, nó keep track với mọi node nên ta dùng được.
  => Quy trình: 
priority_queue lưu tối ưu, các mảng khác lưu data nếu cần
add vào trong queue và mảng data của node đầu tiên
while(điều kiện gì đó để dừng){
  lấy từ priority_queue ra cái tối ưu, phải check nếu lấy ra là đk k thỏa mãn thì pop
  push cái edge tối ưu này vào trong queue
  while các node gắn với node bên ngoài
    cập nhập priority_queue và mảng khác khi thêm node mới đó
}
Dynamic với graph:
 -Tìm Shortest path weight graph directed: path[w đến a] = min(path[k đến a] + weight[k->w]) với k tính dần từ a dùng Djiska. Để có thể tính được buộc duyệt hết các node vì có thể 1 node nào ở cuối có đường tắt đến đích k biết được. Để build được từ a đổ đi hết như thế thì phải duyệt. Mà thuật toán duyệt thì có Kruskal, BFS, DFS, PRIM. Ta có thể dùng PRIM or BFS ok. Nếu dùng BFS sẽ tốt hơn cho graph unweight, còn với weight graph thì phải chú ý 1 điều là các node đã duyệt, nếu res của nó được update do tìm được 1 node có quãng đường ngắn hơn thì phải duyệt nó lần nx. Vì quãng đường từ nó đến gốc được update ngắn hơn thì các node xuất phát từ nó cũng phải update lại quãng đường ngắn hơn chứ nên phải duyệt lại. Còn PRIM thì dễ hiểu hơn. PRIM là 1 kiểu duyệt khác của BFS khi thay queue bằng priority_queue và nó có bước update nhưng ở TH này k cần vì ta k lưu thêm mảng gì chứa thông tin của mọi node khác so với cục tách riêng cả
 -ICBUS mỗi cities có fee và energy, tìm cách đi từ cities này đến cities đầu tới cuối rẻ nhất: ta có thể tự nghĩ BFS và nếu queue rỗng mới dừng. Nhưng cách chuẩn bài này là tạo ra 1 graph mới bỏ đi energy vì mọi cities có thể đi trực tiếp chỉ dùng bus của thành phố hiện tại thì ta coi nó là 1 edge mới luôn. Sau khi có graph mới dùng Djiska để tìm đường đi ngắn nhất. VD 1236 tốn nhiều hơn 151236 vì bus số 5 rẻ hơn thì tất cả điều này đều có hết trong graph mới là từ 1 đến 5 và từ 5 đến 6 trực tiếp r thì Djiska sẽ lấy nó nếu nó ngắn nhất. Để xây graph mới thì ta phải xây BFS từ từ sau đó check nếu capacity thỏa mãn thì add vào r reset từng node.
 -Tìm k-route minimum trong weight tree graph k là cycle: [m][n] là minimum weight từ node thứ m trải dài n-route đổ đi.
Vd: 1 -> 2 -> 3
           -> 4
           -> 5
      -> 6 -> 7
Khi duyệt xong nhánh ta backtrack về chẳng hạn từ 2 về 1 và ta cần xây mảng [1][2] thì [1][1] = min([1][1], [2][0] + 1->2) và [1][2] = min([1][2], [2][1] + 1->2) với mặc định rằng [2][1] đã là minimum 1-route bắt đầu từ 2 đổ xuống trong tree có sẵn r. Vấn đề là kết quả nó là 6->1->2->4(giả sử length = 3) mới là min thì sao => ez dưới vòng for tức là sau khi duyệt xong node 1 ta phải check tiếp nếu size > 1 thì lấy ra 2 và 6 cập nhập res = min(res, [6][x] + 2[y]) với x + y + 2 = 3 thì for phát là xong. Tuy nhiên kp chỉ có nhánh 1 mới phải quan tâm mà mọi nhánh như nhánh 3, 4 bên dưới nó có thể ra nhiều nhánh khác nên ta làm vói mọi nhánh nhưng DFS nó gọi recursive làm hết r nên ta chỉ cần xử lý với node 1 là mọi node khác được tự động có. Lỗi thg sai: phải check node ta for nó khác node parent. Ta cập nhập res mỗi khi kết thúc 1 vòng for dfs và cập nhập res mỗi khi check cái node hiện tại xen giữa như v. Ở đây xh 3 vòng for lồng nhau. for các con của node 1, for tiếp các con của node 1 khác node trước và for k lặp nhé. Với mỗi cặp giá trị lại for tiếp x và y từ 0 đến 3-2=1. 
Backtrack với graph:
 -Đếm spanning tree: ta backtrack duyệt các edge vào numberOfVertices-1 vị trí miễn là k tạo cycle thì lấy, để check cycle đó ta dùng Union_Find cho nhanh. Phải lưu biến Union_Find lại => Lỗi thg sai: dùng backtrack với Union_Find thì có lỗi là uf ta phải dùng biến temp để lưu lại trước khi đổi chứ k được dùng làm đối số truyền vào hàm vì đổi ở turn này sẽ ảnh hưởng turn sau vì find của cả tập Union_Find bị đổi; Chú ý backtrack lỗi vòng for, i phải từ start đến cuối vì ta không muốn lặp => rất hay sai lỗi backtrack kiểu này vì nếu duyệt 123 và 213 coi là 1 thì phải dùng kiểu tổ hợp k lặp truyền thêm biến start vào hàm. Thông thường chỉ có duyệt số mới cần lặp thứ tự chứ duyệt các thứ khác như này nhớ phải có start; Khi khởi tạo biến Union_Find do ta dùng operator nên phải có Union_Find uf(0); sau muốn gán uf = Union_Find(numberOfVertices); ok chứ k được bỏ (); Còn 1 lỗi nx là duyệt các edge ta k quan tâm đến các edge nối với node hiện tại như BFS hay DFS nên lưu luôn struct thôi
 -Tìm MST có diameter of tree <= k: backtrack lấy từng edge tạo cây dùng union_find để k lấy cycle, nếu đủ cây thì dừng, tính weight mỗi khi thêm edge và weight + minweight*số edge còn lại phải nhỏ hơn weight min đã tính thì mới lấy vì cần Minimum tree mà, kết thúc thì viết DFS tính depth của tree nếu depth nhỏ hơn maxDepth thì lấy. Chỉ thao tác được với max 15 vertices thôi, do tầm đó thì check depth là hằng số nên k sợ, union_find bản chất đã loại bỏ cycle nên tốc độ rất nhanh k sợ j hết =>Các lỗi hay sai: k reset hết biến sau mỗi lần check; k tính trước nên lưu kiểu dữ liệu như nào, cần lấy trực tiếp index thì phải lưu mảng trực tiếp; Khi DFS mỗi khi for 1 node mới, kể cả tree k có cycle cx phải check node đó khác node parent=> DFS nên mặc định truyền thêm parent vào để làm điều này sẽ tốt hơn vì kể cả directed mà multigraph ta cx nên check như v.
 -Longest Path vói số liệu lớn trong cây: ta search BFS từ 1 node và tìm node xa nhất với node đó trong cây-> xong lại search tiếp từ node xa nhất đó đổ đi và lấy node xa nhất với node đó tiếp thì là kết quả. Longest path ở đây là weight lớn nhất đó.
=> tính chất đặc biệt là trong 1 cây thì duyệt từ 1 đỉnh tới đít path dài nhất từ đỉnh đó, xong lại duyệt phát nx từ đít là được weight max.
VD: có 1 nhánh nó tõe ra 3 nhánh. ta duyệt từ 1 đầu tới ngã tư thì nó sẽ tính 1 trong 3 nhánh đó cái nào weight lớn nhất thì lấy. Khi đó, longest path trong cả tree chắc chắn phải chứa đít nhánh đó. Vì nếu k chứa đít nhánh đó thì phải chứa 2 nhanh còn lại trong ngã tư. Mà 2 nhánh đó nhỏ hơn nhánh ta chọn nên mâu thuẫn. Suy ra nhánh ta chọn là max trong 3 nhánh và buộc phải có trong longest path

=> Greedy:
 -POSTMAN chuyển phát hàng: để đi nhanh nhất thì các ô xa hơn phải được ưu tiên đi trước để số lần đi các ô đó là ít nhất còn dư kiện hàng mới đi vào các ô ngắn hơn
 -Đổi tiền mệnh giá Mỹ: 1, 5, 10, 50, 100, 500 => trừ dần đi từ mệnh giá lớn nhất là ra số money notes cần trả lại
 -Schedule job có start và finish time k overlap nhau và chọn được nhiều job nhất: sắp xếp các job theo thứ tự finish sớm nhất đến muộn nhất-> lấy lần lượt cứ k overlap cái trước đó là lấy
 -Planting tree trồng cây sao cho mọi cây trồng xong hết sớm nhất là bao nhiêu ngày: sắp xếp cây theo thời gian trồng cây lâu nhất trước, nhanh nhất sau. Duyệt nếu currentDay+số day để cây này mọc lên lớn hơn res thì update res.
 -Mỗi job có 1 deadline và profit, hoàn thành trước deadline thì nhận profit, chọn các job để profit lớn nhất sao cho 1 lúc chỉ làm 1 job: duyệt ngược từ lớn về nhỏ cái deadline và dùng priority_queue tạo maxHeap add các job vào. Mỗi 1 mốc thời gian trôi qua là lấy pop 1 job có nhiều profit nhất từ queue ra và tính. Vì ta duyệt ngược lên mọi job trong queue đều available k quá deadline ở thời điểm hiện tại.
 -ATM đổi tiền từ 1 tờ thành các tờ 1000*10^c,2000*10^c,3000*10^c,5000*10^c in ra số lượng tờ tiền ít nhất và số cách đổi: đúng là nó greedy như tiền Mỹ nhưng ta phải gọi vòng for giảm dần các mệnh giá. Ta trừ đi tờ tiền mệnh giá lớn nhất đến khi nào nó nằm trong vùng của c-> lấy chữ số đầu tiên của nó và check từ 1 đến 9 lấy ra lượng tờ tiền và số cách đổi. Với lượng notes ta cộng dần lên còn số cách ta nhân dần lên. Nếu đến cuối giá trị khác 0 tức nó không chia hết cho 1000 thì là sai.

=> Branch and bound: 
 -Traveling saleman: đi từ thành phố 1 for các thành phố khác với chi phí nhỏ nhất-> nếu k == n - 1 là đi hết các thành phố thì check. Lưu biến thành phố mới nhất đang đi tới, backtrack xong phải lùi lại. Nếu chi phí hiện tại < chi phí tốt nhất thì mới try(chi phí hiện tại cộng với minFee*số tp còn lại). Ở mỗi vòng cộng fee lên.
 -BCA asign course to teacher k conflict và teacher có list các môn dạy được: Try các môn học for các teacher vì ta nhét môn học vào teacher-> nếu teacher dạy được môn này-> for các môn học trước đó, môn nào teacher này cũng dạy mà conflict thì continue -> nếu số lượng môn teacher này dạy lớn hơn max load lưu max số môn của mọi teacher thì update max môn mọi teacher-> nếu số môn đã duyệt đủ mọi môn thì update res với max load. branch and bound nếu maxNum >= res thì cx k Try nx
 -CBUS trở khách từ i đến i + n có giới hạn load fee min: nếu chưa visit-> nếu bus trống thì check trở từ 0 đến n thì ok-> nếu bus có người nhưng chưa full thì check nếu trở thêm khách mới tăng quantity hành khách, nếu trở tới đích giảm quantity hành khách-> nếu bus đầy r thì check trở từ n đến 2n ok -> nếu đi hết các 2n ô r thì cập nhập kết quả-> nếu curRes + fee thấp nhất*quãng đường possible còn lại < res thì mới Try. Phải có biến lưu vị trí gần đây nhất để tính fee từ node đó tới node hiện tại.
 -Tours số cách đi hết thành phố với fee <= M: truyền cities hiện tại vào hàm. fee hiện tại + minFee*quãng đường còn lại <= M mới try tiếp. backtrack xếp cities vào n vị trí thứ tự đi.

=> PP tự nghĩ:
PP thao tác với mod:
 -Tính mod của tổng, tích: dùng (a + b + c) mod n = a mod n + b mod n + c mod n và (abc mod n) = (a mod n)(b mod n) mod n
 -Tính mod của a^b: dùng (a^b mod c) = (a mod c)^(b mod (c - 1)) mod c với c là số nguyên tố
 -Tính mod của Cnk: Cnk = C(n-1)(k) + C(n-1)(k-1) % modVal có thể build từ trên xuống với đệ quy recursive or build từ dưới lên với loop. Chú ý đệ quy với memorization phải check tồn tại ngay từ đầu, sau đó mới check đk dừng, return giá trị memorization.
PP cây mọi trường hợp + breadth first search:
 -WATERJUG đổ nước qua lại 2 ly để được 1 mốc: khởi đầu (0,0) có 6 actions: đổ đầy 1 và 2, đổ ra 1 và 2, đổ 1 sang 2 và 2 sang 1. Dừng khi 1 trong 2 bình có kết quả thỏa mãn. Ở mỗi node d[u][v] là số bước nhỏ nhất cần đổ đạt được u,v ở 2 cốc. Ở node hiện tại nếu d[u][v] đã set thì k push vào nx. Nếu queue rỗng mà chưa đạt được giá trị cần tìm thì trả ra 1. d[0][0]=0 và các node sau cứ d[u sau][v sau] = d[u][v] + 1 là xong
 -Tìm đường thoát khỏi maze mảng 2 chiều 0 1(ez)

PP dynamic tư duy tuyến tính: 
 -Tìm phần tử nhỏ hơn phần tử hiện tại ở xa nhất sau phần tử hiện tại trong mảng, thực hiện với cả mảng 10^5 phần tử: duyệt từ cuối, sẽ bỏ được mọi giá trị lớn hơn trước nó. Nhưng nếu sắp xếp tăng dần sẵn thì sẽ thành O(n^2) mà 10^5 thì max là O(nlogn) nên phải tăng tốc đoạn tìm phần tử lớn hơn ở trước nó => sắp xếp tăng dần giá trị-> duyệt từ cuối nếu ptu chưa tính-> tìm phần tử ở cuối đó trong mảng đã sx binary_search-> tính và xóa mọi phần tử lớn hơn, check các ptu đó là đã tính xong-> duyệt tiếp đến hết


Hướng dẫn các PP:
*)Backtracking: 
Vc duyệt có lặp hay k lặp tùy bài toán VD xếp đồ vào túi thì TH đồ A, đồ B và TH đồ B, đồ A theo thứ tự ta coi là 1 thì dùng start duyệt k lặp nhưng TH duyệt thành phố đi từ A->B->C và đi từ B->A->C thì chi phí khác nhau và phải duyệt cả 2 cái thì ta duyệt có lặp
Nhiều lúc cái backtrack ở phần điều kiện dừng thỏa mãn ấy, ta éo cần check điều kiện mà cập nhập liên tục. Tương tự cái này là tùy bài toán có cần thiết phải đi đến cuối mới cập nhập k hay có thể cập nhập sau mỗi vòng for. VD bài Knapsac ta cần lấy maxVal thỏa mãn khối lượng thì có thể cập nhập maxVal = max(maxVal, curVal) ngay trong vòng for mà chả cần điều kiện dừng gì cả vì cho 1 món vào và cho 10 món vào túi thì cập nhập maxVal chả ảnh hưởng. Nhưng bài TSP thì phải đi đến cuối mới cập nhập vì cần lấy min nên phải đi đến cuối ms lấy chứ, nếu ban đầu =0 mà lấy thì min là 0 luôn à
Giải quyết 2 vấn đề: xây dựng tập candidate Sk tổng quát khi đã có S(k-1); tạo vòng for lấy các phần tử trong Sk
Có 3 hướng đi: xây tập Sk chỉ toàn candidate và for nó; for tất cả và gọi hàm checkCandidate để check xem phần tử hiện tại có phải là candidate hay ko; for tất cả nhưng không dùng checkCandidate nữa mà thêm thông tin vào biến để vòng phía sau không dùng các thứ đã đánh dấu ở vòng trước và xóa thông tin sau khi backtrack xong. 
Để làm theo hướng 3 thì ta phải tìm được điểm chung của các ô duyệt rồi lưu vào 1 mảng tuyến tính
Bên trong vòng for cần rút gọn đến mức tối thiểu. Vd: viết a = b = c; nhanh hơn so với viết 2 dòng
Sắp xếp cái mảng mà ta for theo 1 chiều nào đó trước rồi mới backtrack=> ví dụ trong lúc backtrack mà cần tìm min của phần còn lại thì quá ez sắp xếp giảm dần và lấy min phần còn lại luôn là fix phần tử cuối(duyệt k lặp=> backtrack thg là duyệt k lặp). Tương tự nếu trong quá trình backtrack mà muốn tìm cái gì độc nhất của phần còn lại thì nên sắp xếp sự độc nhất đó từ trước khi backtrack để nó dí ở phần tử thứ n. 
Để duyệt k lặp, ta dùng biến global start truyền vào lúc bắt đầu mỗi vòng for backtrack, or nếu có thứ tự tăng dần hay gì thì chỉ cần check cái sau phải lớn hơn cái trước mới đi tiếp là được
Các bài check điều kiện backtrack mà dùng đến for thì thời gian thg là hằng số và số lượng phần tử rất nhỏ(k quá 30). Chú ý số lượng phần tử vì kp bài nào ta cũng check với O(1) được mà phải dùng vòng for, đừng có thấy vòng for phát là tưởng sai nghĩ cách khác.
Nếu backtrack mà cần lưu check lại mà sợ sau khi backtrack xong k lấy lại được nx thì có thể dùng mảng để lưu gắn liền với phần tử thì dữ liệu phần tử trước đó vẫn được lưu trong mảng khi backtrack về nên k bị mất VD như bài binary list dùng mảng để lưu số lượng phần tử 0 kết thúc gắn với phần tử hiện tại
Tư duy backtrack viết ngắn lại 
=> Tham số truyền vào hàm có thể dùng để lưu dữ liệu. VD có 1 dữ liệu mà sau khi xử lý data tại ith ta không biết nó biến đổi thành cái gì và sau đó ta backtrack lại thì cần dữ liệu cũ, khi đó ta thường dùng biến saveData để lưu lại trước khi thay đổi nhưng như v là không nên, ta nên truyền nó làm tham số cho hàm để lấy nó global sẽ tốt hơn. Bất cứ khi nào cần saveData nên nghĩ đến cách này đầu tiên.
=> Tư duy quá gò bó. Bên cạnh việc tìm được Sk và for các phần tử Sk, vấn đề quan trọng nx là tìm điều kiện dừng, ta cũng cần hiểu là đang xếp cái gì vào cái gì. VD bài xếp cities vào position, xếp ngoặc vào "?" thì nếu hiểu như v ta có thể trình bày backtrack đơn giản hơn là thủ công nhiều. VD bài KBracket ta xây tập Sk là ( và ) xong for nó, nhưng vì tư duy quá gò bó nên lúc nào gặp backtrack ta cũng phải xây riêng ra 1 tập Sk chứa các giá trị để điền vào và cách đó nhiều khi rất chậm. Ta cứ nghĩ phải xây 1 tập riêng lưu các position có "?" để xếp vào. Như v là không tốt, điều kiện dừng ở đây là khi tất cả các position đều có ngoặc thì ta nên Try theo index của cả string và dừng khi đi đến cuối string và thỏa mãn, kp lúc nào cũng xây riêng ra 1 tập để for mà có thể for tất cả gặp cái gì thì mới cần xử lý như v=> Bài Bracket có thể làm 3 if else r backtrack bên trong chứ k xây tập riêng gì cả. Về sau bước lấy kết quả, gọi lại và backtrack có thể gộp vào 1 cục bên dươi or not
Chú ý xếp a vào b thì ta có thể tạo 1 tập hợp các vị trí trong b để xếp a vào or cách khác là xếp a vào mọi b, cứ if else ngoài vòng backtrack xem khi nào cần xếp như nào thì xếp, điểm lợi là ta không chỉ xếp vào các vị trí có thể xếp mà các vị trí k xếp ta vẫn có thể duyệt qua được và tùy ý cần tính toán hay bỏ qua đều được. Tương tự có thể xây 1 tập candidate của a để duyệt or cách khác là duyệt toàn bộ a và nếu cái nào thỏa mãn thì lấy ok hết => để ý xếp cái gì vào cj và chọn cách phù hợp. Để biết xếp cái gì vào cái gì thì phải hiểu xếp a và b thì b là thứ phải có đầy đủ, a là thứ có tùy ý và điều kiện dừng thg là b có đủ rồi. VD bài BCA xếp lịch hoạt động cho giáo viên thì chỉ khi mọi môn học đều có giáo viên dạy mới được thì b là môn học còn a là giáo viên. Ta phải for giáo viên xếp vào môn học này và đk dừng khi tất cả môn học được xếp=> ez.
Lỗi sai backtrack: ta check điều kiện candidate này ok, xong xử lý, xong check đây là candidate cuối or not thì check đk branch and bound để try tiếp, k được thì mới backtrack nhưng nên nhớ các điều kiện phải chặt k sót cái nào. VD ta nhận candidate này là thỏa mãn và lấy, nhưng khi xử lý nó xong ms check được là nó không thỏa mãn, xong nó gặp check dừng với branch and bound lại k check được cái điều kiện không thỏa mãn đó nx, nếu như nó gọi vào try ok lấy kết quả được thì là làm sai r => Ta có thể, gộp nó vào hàm check, check kỹ hơn từ trước đó kiểu nếu cộng vào thì k thỏa mãn thì k cộng nx. Or nếu k làm được như v thì có thể bao đk dừng và đk try trong 1 vòng if else và check nếu if else đó thỏa mãn mới xử lý 2 cái đó, còn k thì tự chạy backtrack bên dưới, nhưng nhớ là việc check như v k được dùng for, có thể tạo mảng or làm bất cứ thứ gì chứ dùng for là tèo => lỗi này chung quy lại là phải check điều kiện thỏa mãn nếu ta xử lý ith thì thấy thỏa mãn r thì sau đó mới xử lý ith
*)Branch and bound:
Check biến curRes kết quả đang tính với biến res là kết quả đúng nhất ở thời điểm hiện tại. Nếu curRes mà kém hơn kết quả đúng nhất res thì dừng luôn
Mở rộng hơn nếu curRes kèm với phần data còn lại cứ cho là tốt nhất nếu vẫn kém hơn res thì k Try nx
next_permutation(first, last, (bool)); hiển thị theo thứ tự từ điển
Đặc biệt: backtrack for k lặp thì từ 0 tới n thì n luôn là phần tử cuối cùng trong "phần data còn lại" nên có thể gán n là phần tử đặc biệt để lấy bất cứ lúc nào. Ngoài ra backtrack còn có k tăng dần nên nếu ta duyệt đến 1 số nào đó thì ta có thể dùng tính chất các k đã duyệt là mọi k nhỏ hơn k hiện tại. VD bài BCA xếp môn cho giáo viên thì ta duyệt các môn đã học(từng duyệt qua) rất đơn giản là for từ 1 đến k là xong-> tc tận dụng
Tạo ra rất nhiều mảng để cho tốc độ tìm kiếm là O(1). VD BCA có 4 giáo viên 15 môn thì mảng 2 chiều [4][15] để check giáo viên nào đã dạy môn nào với speed O(1)
Trước khi tạo mảng mới để check hãy tinh ý các ĐK ràng buộc dựa vào data có sẵn xem có check được luôn k. VD bài CBUS để check ô i+n đã visit chưa ta có thể check xem ô i đã visit chưa mà k cần tạo thêm 1 array mới, nhưng ô i để đi được tới tức là nó đã chưa visit nên có thể chắc chắn ô i+n lúc đó cx chưa visit
Giá trị k có thể tái sử dụng ta toàn quên. Để lưu vị trí gần nhất visit ta dùng 1 mảng tận dụng luôn k là cur[k - 1], update mỗi khi visit 1 node mới, khởi tạo cur[0] là node đầu tiên đi, k cần backtrack cur. VD: ở k = 5 sau ta backtrack về k = 4 thì cur[3] đã có lưu đi từ node nào sang node k = 4 này r=> thôi
 => các lỗi không tỉnh táo TSP: khi đi đến cuối cũng phải check xem có đường đi quay lại thành phố đầu k đã chứ; isVisited luôn là thứ gán đầu tiên và backtrack đầu tiên đừng quên; khi backtrack đi từ thành phố 1 ta phải nhớ gán thành phố 1 đã đi or dùng for từ thành phố 2 trở đi
*)Divide and conquer: 
Thực tế ta có thể divide dựa vào giá trị min, max tùy bài chứ kp lúc nào cũng chia đôi. Khi đó có thể dùng segment tree có sẵn để tăng tốc độ chia.
Tìm cách chia bài toán lớn thành nhỏ-> nếu đủ nhỏ thì giải được kết quả luôn-> gọi đệ quy các bài toán con và coi là đã giải được-> kết hợp nghiệm các bài toán con lại
Chia để trị cũng như là duyệt qua các phần tử với độ phức tạp log2n v
Quy tắc thg dùng là chia 2 nửa và kết quả có thể nằm bên trái, bên phải or 2 bên. Cách chia thì tùy bài. Nếu bên trái or phải thì giải base case là đc còn 1 phần trái, 1 phần phải thì khi dựa vào tính chất đó và việc đã tính được bên trái và bên phải rồi, bài toán phải đơn giản hơn bài toán gốc là cả tập. Nếu giải 1 phần trái, 1 phần phải dựa vào các dữ kiện đó mà k dễ hơn or nhanh hơn thì là dùng sai divide and conquer.
Khi ta xử lý tìm min chẳng hạn mà nếu biết 1 Th k thỏa mãn có thể return 9999; và ngược lại tìm max có thể return 0; khi xử lý case tùy bài
Nếu làm divide như bth thì duyệt O(log2n) k tính duyệt TH 1 phần trái, 1 phần phải. VD bước combine 2 nửa ta duyệt toàn bộ 1 lần trái, 1 lần phải thì độ phức tạp sẽ thành O(nlogn) và chỉ khả thi với 10^6, nếu lâu hơn or n lớn hơn sẽ k thỏa mãn. Cứ lấy độ phức tạp bước combine 2 nửa nhân với logn để biết cách hiện tại có ok với n phần tử hiện tại k. Chia T(n) = T(n-1) ~ tuyến tính. 
Dùng DaQ với đệ quy thì phải tính xem có memorization được k vì đệ quy tuyến tính thì được chứ đệ quy có nhiều biểu thức như fibonacii thì nên memorization.
Có thể dùng DaQ lồng DaQ tức dùng thêm DaQ trong các bài toán con DaQ của nó. Để nghĩ ra thì mỗi khi giải bài toán nên nghĩ xem có chia nó ra tiếp thành các bài toán con hay k và các bài toán con lại nghĩ chia tiếp như v.
Nên nghĩ đến việc sắp xếp or xử lý gì đó trước khi dùng divide and conquer để giúp bước xử lý 2 bên dễ dàng hơn.
Dạng divide and conquer chặn low, high: bài scriber và aggrcow mở ra dạng này cần master. Nó khác với các bài eko hay pie là mỗi người có 1 lượng bánh như nhau, cưa 1 mức như nhau với tất cả các cây thì biến ta đặt là mức cưa or lượng bánh như nhau mà mọi người nhận được. Với dạng bài này phức tạp hơn vì số lượng sách và kc liên tiếp của 2 aggrcow là khác nhau mà ta kb trước. VD phân tích bài aggrcow: ta cần tìm max khoảng cách ngắn nhất giữa 2 con bò liên tiếp. Kc 2 con bò liên tiếp ngắn nhất là lớn nhất thì Th lý tưởng là chúng cách đều nhau, ở đây thì ta phải xếp vào các chuồng cách nhau k đều. Ta đặt biến kc min của 2 con bò liên tiếp và tìm số lượng bò thì chú ý là khi tìm số lượng bò, ta cho kc giữa 2 con bò >= kc min đó từ barn ở 1 đầu mút đổ đi và tìm ra số lượng bò thì số lượng bò đó >= số lượng bò thực tế khi dùng khoảng cách đó. Quả đúng là như v ta cứ >= kc min là + 1 con bò lên thì các vị trí xếp bò đó đã là tối ưu để có số lượng bò nhiều nhất. Do đó số lượng bò nhiều nhất đó ta phải so sánh >= số bò hiện tại thì return false chứ k đc làm kiểu <= số bò hiện tại vì số bò thực tế <= số bò tính ra mà. Nếu lớn hơn số bò thì có thể là Th đúng nhưng nhỏ hơn thì chắc chắn sai. Tức là TH này kp là k thỏa mãn mà là có thể thỏa mãn. Khi đó ta sẽ dùng left = mid + 1 chứ kp left = mid. Vì nếu left đó là Th thỏa mãn và left + 1 k thỏa mãn thì ta while(left <= right) nên khi right < left tức là right bằng đúng giá trị đó ta return right là quá chuẩn r. Ta tinh ý như v khi gọi left hay right. Bh ta cứ cố định là while(left<=right) và lấy right thì khi gặp TH có thể đúng ta phải left = mid + 1 ngay. Xét bài scriber, biến là số trang max mà ta assign cho 1 scriber tức là sô lượng scriber ta tính ra sẽ <= số lượng scriber thực tế. Nên ta phải check là số lượng nhỏ nhất đó mà vẫn lớn hơn số lượng scriber đề bài cho (tức là thực tế lấy mid đó cx lớn hơn đề bài cho) thì chắc chắn là sai r, ta phải assign nhiều task hơn cho 1 scriber để giảm lượng scriber đi. Khi đó task ta tăng tức left = mid + 1. Nhưng chú ý là khi số lượng scriber tính ra <= số lượng scriber đề bài cho thì thực tế số lượng scriber nhiều hơn số lượng tính ra(vì TH task assign 1 1 1 1 mỗi scriber ít nhất 1 sách sẽ tạo ra nh người hơn) nên TH này có thể vẫn đúng, thì ở đây ta có thể vẫn lấy nên ta dùng right = mid - 1 và giả sử nó đúng thì mid ở TH cũ đúng vì right = mid - 1 sai. Khi right < left thì ta dừng lúc này ta phải lấy left vì left sẽ nằm ở vị trí mid cũ là vị trí đúng => tức là ta làm hoàn toàn bth ngoại trừ vc kết quả cuối lấy left hay right thì sẽ phụ thuộc vào Th đó có thể đúng hay sai và đặt biến là gì. Tùy biến VD bài aggrcow ta có thể check ngoài vòng for số bò <= thì chơi or trong vòng for mà số bò tính ra >= số bò hiện tại thì Th này có thể vẫn đúng nên ta cho low = mid + 1 và lấy high. Chú ý trong vòng for ta k thể check số bò <= số bò hiện tại vì ta khởi tạo từ 1 bò thì lúc nào mà chả nhỏ hơn thì luôn return true. Vấn đề nx là ta muốn check số bò <= số bò hiện tại ngoài vòng for thì chắc chắn phải giảm kc 2 con bò gần nhất đi nhưng ở đây dấu = sai vì bằng thì có thể thỏa mãn mà Th này ta đang xét chắc chắn k thỏa mãn để giảm mid đi mà nên phải bỏ dấu bằng đi
2 Vd là 2 Th phân tích khác nhau nhưng cùng chung 1 mục đích là về cuối ta lấy phải chú ý.
Ta có thể đặt biến số với 2 dạng: x là cái gì cần tìm sao cho x=a thì giá trị cần tìm > giá trị đb cho và x=a+1 thì giá trị cần tìm <= giá trị đb cho thì làm bth xong quyết định lấy giá trị nào; x là cái gì cần tìm sao cho x>a thì giá trị cần tìm > giá trị đb cho và x<a thì giá trị cần tìm < giá trị đb cho nên x=a là gt cần tìm
*)Dynamic mảng 1 chiều:
Dynamic nó hay kiểu xây 1 mảng [i] là cái cái gì tối ưu kết thúc tại ith là 1 mốc nào đó.
Chỉ duyệt 1 lần đi đến đâu tính đến đấy, ta phải tìm cách giải từ việc tính toán gắn với mỗi phần tử. Khi đến 1 phần tử nào đó thì ta cần tính cái gì gắn liền với phần tử đó phục vụ cho kết quả và cần cho việc tính các phần tử sau. Và để tính cái gắn liền với phần tử hiện tại chỉ được dùng giá trị hiện tại và các giá trị phần tử trước đã tính. 
Chia đủ TH khi gặp 1 phần tử mới. VD HIST thì 1 ô mới chỉ có thể > < = ô vừa duyệt mà thôi thì xử lý đủ các TH đó
Đôi khi không giữ được O(n) mà phải dùng for để tính giá trị phần tử hiện tại => tùy vào kích thước n
Để tìm ra cách giải, ta dùng pp đơn giản hóa, giả sử số lượng phần tử chỉ có 1, 2, 3 chẳng hạn thì tính ra như nào xong dựa vào kinh nghiệm mò ra mảng lưu gì. Nó kiểu inductive ấy, phải tìm ra dynamic formula. Nếu là base case thì giải luôn, nếu k là base case thì đi từ con sang cha + số liệu hiện tại và data đã tính dựa vào formula. Chú ý các bước giải phải là tuyến tính, nếu tính cha từ con mà dùng vòng for thì độ phức tạp sẽ nhân thêm vòng for đó và n phải nhỏ đi mới được.
Với các TH vòng for thứ 2 tính max min hay gì đó nhất trong mảng thì ta có thể dùng priority_queue để giản lược vòng for 2 thành O(1)
Cái mảng ta duyệt dynamic có thể phải biến đổi thành 1 mảng khác mới dynamic được. dynamic level2 phải biến đổi mảng đó or đảo chiều này nọ mới dùng được dynamic. Khi các bài dùng đơn giản hóa k ra dynamic, khả năng phải biến đổi đấy, VD bài max even subarray. Or bài MACHINE phải tạo thêm 1 mảng nx bổ trợ cho việc tính dynamic dễ hơn nh.
Khi đã đơn giản phần tử mà vẫn k ra, thử đơn giản hơn nx bằng cách chỉ dùng 1 loại phần tử, xong cứ chia nhỏ dần nx để đơn giản đến mức giải đc thì thôi
Khi ta cố dùng bài toán con để giải bài toán mẹ, nhớ là nó phải tuyến tính và chỉ cần dùng nó cộng với số liệu hiện tại thôi, làm sao cho phép tính đó là O(1), nếu lớn hơn thì nhìn vào kích thước data
Thg lưu bằng mảng, or nhiều lúc cũng lưu bằng 1 biến int r update biến đó
Để giải mẹ từ con, ta phải luôn đinh ninh rằng ta có đáp án tất cả các bài toán con rồi và đặc biệt sử dụng bài toán con ngay sát nó để giải bài toán mẹ chỉ vs 1 bước.
*)PP dynamic tư duy tuyến tính 1 chiều: 
Đơn giản hóa vấn đề cho kích thước nhỏ r tăng dần lên
Duyệt tuyến tính đảo chiều linh hoạt
Khi dùng xong 1 giá trị k cần tính nx thì bỏ khỏi mảng luôn để giảm tải khi tính tiếp đợt sau
*)Dynamic mảng 2 chiều:
Nghĩ sâu vào phần tử hiện tại để tính thì đùng dến các dữ kiện ở đâu và như nào để xây
Nó thường là kiểu [m][n] kết quả cần tìm khi dùng đến n thứ gì đó cho đến mốc m nào đó. Có vài TH mảng 2 chiều chỉ để chia TH nhỏ hơn tính cho dễ như bài nurse chia làm 2 loại 1 là kết thúc bằng ngay nghỉ, 0 là kết thúc bằng ngày làm việc. Thứ cuối cùng cần có là n là dùng tất cả còn m là mốc cuối cùng đề bài hỏi => tưởng tượng m và n là số lượng 2 thành phần hàng và cột của table và các cái đó là ta đang duyệt qua đó với 1 số bài sẽ giúp dễ hiểu hơn.
Để có thể tìm được formula, ta phải hiểu khi mảng 2 chiều có m, n tăng thêm 1 đơn vị thì có chuyện gì mới xảy ra và tập trung xử lý liên quan đến cái dữ kiện mới có được giả sử có hết dữ kiện cũ rồi. Ta phải nghĩ theo hướng đó thì có thể giải quyết formula inductive trong 1 nốt nhạc
Làm rõ vấn đề về formula: arr[i][j] = arr[i][j - k] +... Ta cần đặt đúng vai trò arr này là gì. VD: bài [m][n] dùng đến m xu tạo ra giá trị n thì ok. Nhưng bài chia cửa hàng cho chi nhánh có saleman sao cho số cửa hàng 1 chi nhánh chia hết số saleman chi nhánh đó và mỗi chi nhánh có ít nhất 1 cửa hàng thì [m][n] nên là chia m cửa hàng cho n chi nhánh sao cho chắc chắn có chi nhánh n => [m][n] = [m - f[n]][n] + [m - f[n]][n] => tức chia m cửa hàng cho n chi nhánh chắc chắn có chi nhánh n tương đương với chia m-f[n] cửa hàng cho n chi nhánh sao cho chắc chắn có chia nhánh n và ko có chi nhánh n => chú ý bao đủ mọi TH nhé. Chứ bài này chia [m][n] là dùng đến n chi nhánh thì formula có thể k viết được luôn. Phải đặt đúng đề bài cho. Đặt thế nào mà có cái gì gắn liền với dữ kiện mới khi m, n tăng lên chứ nếu n tăng thêm 1 chi nhánh mà vẫn có thể k xếp vào chi nhánh đó thì tăng làm mẹ gì
Khi gặp các bài toán mà ta muốn chạy 2 vòng for như kiểu duyệt qua các ngày xong mỗi ngày lại for trạng thái nghỉ hay làm việc thì nên dùng dynamic 2 chiều [m][n] là đến ngày thứ m là trạng thái n làm việc hay nghỉ. Hoặc khi gặp các bài toán backtrack như common subsequence sinh ra mọi tổ hợp có thứ tự của chuỗi 1 và tìm nó for trong chuỗi 2, ta dùng mảng 2 chiều với 2 chuỗi là hàng và cột của table => hay. Mấu chốt nhìn ra bài nurse. Thậm chí nhiều bài như này là ra mà k cần đơn giản hóa
*)Dynamic bitmask:
Nên nhớ iMem[i][S] là chi phí rẻ nhất visit mọi node mà chưa visited ở trong S và bắt đầu từ i. VD đi đến node cuối thì iMem[i][S] = fee[i][1] nếu quay lại node ban đầu(nếu k thì return 0). Còn tại điểm bắt đầu thì hiển nhiên rất lớn r iMem[i][S đã visit node i] = min(iMem[k][S đã visit node i và k] + phí từ i tới k) với k là mọi node liền với i. Quy trình như CBUS là tiêu chuẩn cho dạng này. Qtr cần tùy biến xác định iMem là gì với các bài khác nhau. Thực ra bitmask nó chỉ giúp lưu lấy nhanh hơn chứ k dùng thì dài hơn chút chứ cơ chế vẫn v, VD có thể lưu trong struct
*)Graph:
BFS và DFS cho ta duyệt qua data structure graph theo thứ tự. DFS thì sâu vào, BFS thì duyệt xa dần theo level. Ta có thể ứng dụng 2 kiểu duyệt này để làm rất nhiều dạng bài mà cần duyệt qua graph để làm gì đó
Dạng duyệt BFS: push phần tử đầu tiên, khởi tạo mảng level -1-> pop phần tử đầu tiên, nếu nó là kq thì lấy r exit-> đi các bước tiếp theo từ nó nếu thỏa mãn và level của nó khác -1 thì push và queue và gán level nó bằng level node này +1
Thuật toán tarzan cho ta check bất cứ khi nào gặp bridge
Khi cần lấy nhiều phần trong graph cũ để check. Thực ra rất đơn giản vì 1 graph chỉ được biểu diễn bằng 1 adjacency list nên ta có thể tạo 1 adjacency list mới và add các cặp edge vào. Thông thường sẽ là ta duyệt cái list cũ, duyệt qua mỗi edge, nếu edge đó thỏa mãn thì list mới sẽ add vào mà thôi. Đây cx là cách khi ta muốn bỏ 1 vài node hay edge ở trong graph đi.
Cấu trúc Union_Find: thuật toán tốt nhất nếu có nhu cầu duyệt edge rời rạc chứ k liên tiếp như DFS, BFS. Ta cứ for cac edge và duyệt, nếu find 2 node của edge bằng nhau thì edge đó là cycle, mặc định loại trừ cycle. Hàm unite giúp lấy edge đó thêm vào tập union-find
Thuật toán PRIM: cơ chế là duyệt từng edge một của graph nối với cái cục tách riêng ra hiện tại. Dùng priority_queue làm cho các edge đó ta lấy ra luôn là cái edge tốt nhất hiện tại-> thêm nó vào trong phần tách riêng-> update các edge khác nếu như ta thêm cái đó vào phần tách riêng đó thì các node khác sẽ đổi như nào. PRIM đảm bảo ta lấy ra 1 tree từ graph và có đầy đủ các node, vì vòng while nó check số lượng edge phải <n-1. Dùng PRIM phải chú ý: xây 2 mảng, 1 là lưu khoảng cách min từ mọi node tới cái tách riêng, 2 là lưu node mà các node này nhắm tới vì cái tách riêng có rất nhiều node biết nối vào node nào=> cái này phải tùy biến vì mỗi bài có kiểu tách riêng và lưu tính chất riêng; Nếu k dùng priority queue, ta tìm cái tốt nhất bằng cách duyệt thì ok, vì k cần push mà ta gán là đổi 2 cái mảng khởi tạo ban đầu. Còn dùng priority_queue thì giảm được vòng lặp kia, dùng priority_queue chỉ là cách tăng tốc độ lấy cái tốt nhất thôi. Khi đó ta push vào nhưng k pop ra được mà trước khi lấy sẽ check nếu là cái lần trước cần pop chưa pop được thì pop ra cho đến khi nào ok thì mới lấy
PRIM là thuật toán tốt nhất cho ta lấy dần dần các thứ trong graph theo 1 tính chất cái gì nhất do ta ý lấy của phần sau so với phần đã tách riêng.
Thực chất PRIM là BFS dùng priority_queue. Thay vì duyệt các node kề với node hiện tại, ta add cái edge dẫn đến node kề đó vào priority_queue và lấy từ queue ra. 
Chính vì PRIM là mở rộng thêm từ BFS nên ta có thể hiểu. BFS bth ta duyệt các edge theo thứ tự BFS nhưng ta nhét edge vào priority_queue để quyết định sẽ lấy edge nào tiếp theo là thành PRIM. Có thể mở rộng nếu queue k empty thì đi tiếp tức duyệt hết các edge or nếu số edge = số vertice - 1 là được tree thì dừng. Có thể mở rộng là priority_queue lấy các edge nối với node hiện tại như BFS or nối với cả cục tách riêng hiện tại bằng cách chạy 1 vòng for update các mảng lưu thông tin mọi node so với cục tách riêng hiện tại. Có thể mở rộng là nếu chưa visit thì visit (bằng cách push vào queue) như BFS bth or nếu for các edge nối với node hiện tại nếu thỏa mãn điều kiện gì thì mới nhét vào queue.
Djiska là thuật toán dùng PRIM(thực chất là BFS) + dynamic

Bất cứ khi nào cần tìm kiếm nhiều thì sort và binary search hơn là duyệt tuyến tính. Search 1 phần tử thì được chứ n phần tử thì nên sort + binary search
*)PP cây mọi trường hợp + breadth first search:
Khởi tạo 1 phần tử cho queue-> while queue ko empty-> pop lấy phần tử hiện tại-> nếu phần tử hiện tại thỏa mãn giá trị cần lấy thì lấy r exit. Nếu k-> lấy ra các phần tử tiếp theo sinh ra từ phần tử hiện tại-> check phần tử hiện tại đã từng duyệt rồi thì bỏ. Nếu ko-> lưu level phần tử hiện tại là level phần tử trước + 1 ->push nó vào queue và đi tiếp -> nếu queue empty mà chưa ra kq thì k có TH nào thỏa mãn
*)PP chặn 2 đầu tính gần đúng giá trị: 
Phân biệt dạng với float và với int: ta tìm được biến số để chặn left và right, tính ra 1 giá trị gì đó mà có thể so sánh với 1 giá trị mà đề bài cho r dịch và chia đôi thôi. Với float thì sẽ chơi while right - left > sai số, với int thì chơi while left <= right thì chú ý lấy left hay right đúng
Chú ý biến là cố định VD bài sách thì mỗi người có 1 lượng pages khác nhau k cố định nhưng ta đặt nó là số lượng trang max assign cho 1 người là thành cố định liền. Biến ta thg đặt là cái gì trong 1 nhóm thì max là bnh, min là bnh.
Dù số lượng phần tử lớn nhưng bên trong ta có thể chạy thêm 1 vòng for để check được. Nếu time limit thì phải nghĩ cách khác check nhanh hơn.
Nhiều bài tìm ra rồi xong phải xử lý TH trùng nhau, ta cứ lấy ví dụ cụ thể ra mà check. Có thể sắp xếp mảng lại tăng dần hay giảm dần vì có thể giúp check nhanh hơn hay xử lý kết quả nhanh hơn


Lưu ý lỗi sai: 
- K khai báo mảng [1e7] nhé, phải viết rõ ra vì nó là double;
- 1 mảng kích thước max 10^7, lớn hơn sẽ lỗi
- If else viết ngoặc bth k bỏ {}
- Gán a = b = c; trong backtrack cho nhanh
- Dùng int thành short chỉ bị timelimit 1 tí
- Thiếu ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); khiến time limit
- Divide and conquer có for chạy từ x đến mid chứ kp từ 0 đến mid
- K được đặt tên là data, index, count, max, min, new
- K dùng break và continue khi backtrack vì nó phải backtrack hết chứ
- Backtrack k dùng k++ mà phải là k+1
- Divide and conquer thì viết muốn thực hiện như nào trước thì viết riêng ra. VD ở bài clopair ta mà gọi return min(recur(nửa phải),recur(nửa trái),a()) nó lại thực hiện a trước cơ làm mất thứ tự đúng là phải thực hiện 2 bên trước thì mới tính a được nên gọi riêng từ trên và lưu lại nhé. Ta chỉ cần đảm bảo nửa trái và phải thực hiện trước là được nên cứ gọi 2 cái đó bên trên là đc
- Lỗi int->long
- memset k gán 1 cho số được
- Unsigned long long với i = 0 thì -- nó ra số cực lớn vì underflow chứ éo ra âm làm ta sai-> nên ưu tiên long long thôi
- Backtrack nên gom vào hàm check để giảm biến goNext trong vòng for
- Thay vì switch case từ 1 đến n lấy giá trị nào ta dùng array n phần tử lưu data lấy ra
- Dùng hàm pow thì phải lưu lại bằng unsigned long long trước tránh sai(ấy là nếu muốn dùng dạng nguyên)
- Cách gán vector clear lại, VD isVisited = vector<bool>(2001, false); Và queue VD queue<int> empty; Q.swap(empty);
- Code kiểu k tập trung kỹ là mình có cái gì và mình cần làm gì để đến được cái gì ấy mà cứ code theo cảm tính là chết, phải hiểu rõ cái thứ mình đang code là gì, những dòng code mình đang viết nó dẫn tới cái gì để đi được tới đích
- Thuật Kruskal sai lỗi iParent[n+1] mới đúng
- Khi làm bất cứ bài nào cần hiểu rõ đề bài. Khi giải bất cứ bài nào cần hiểu tường tận cách giải
- Lỗi thg sai: dùng backtrack với Union_Find thì có lỗi là uf ta phải dùng biến temp để lưu lại trước khi đổi chứ k được dùng làm đối số truyền vào hàm vì đổi ở turn này sẽ ảnh hưởng turn sau vì find của cả tập Union_Find bị đổi; Chú ý backtrack lỗi vòng for, i phải từ start đến cuối vì ta không muốn lặp => rất hay sai lỗi backtrack kiểu này vì nếu duyệt 123 và 213 coi là 1 thì phải dùng kiểu tổ hợp k lặp truyền thêm biến start vào hàm. Thông thường chỉ có duyệt số mới cần lặp thứ tự chứ duyệt các thứ khác như này nhớ phải có start; Khi khởi tạo biến Union_Find do ta dùng operator nên phải có Union_Find uf(0); sau muốn gán uf = Union_Find(numberOfVertices); ok chứ k được bỏ (); 
- Con mẹ nó dùng vector<int> a[3001]; và mỗi phần tử add vào có tí thì bị memory trong khi int a[100001][3000] thì éo bị => rút cục nên ưu tiên array tĩnh để tránh lỗi
- Khi backtracking có start thì k cần isVisited nx; truyền vào start cho vòng sau chính là i+1 hiện tại chứ kp start+1 của vòng hiện tại.
- Thuật sort mặc định là tăng dần, thêm greater<int> sẽ là giảm dần, nếu dùng riêng thì a, b theo thứ tự truyền vào thì sẽ return ra giá trị nếu true thì a đứng trước b và ngược lại
- exit(0);
- Khi đọc data nên lưu từng cục vào 1 struct vì ta có thể sắp xếp mảng theo trường struct đó
- Có các hàm substr(bắt đầu từ index, bao nhiêu phần tử), clear(), erase(arr.begin() + 10) để xóa phần tử index là 10, copy(), make_pair(,)

Code mẫu:
dynamic, graph, segment tree, priority queue
